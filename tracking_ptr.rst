.. contents::
   :depth: 1
   :local:


:cpp:class:`!tracking_ptr\<>` による循環型コレクション
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

xpressive では正規表現オブジェクトがお互いや自分自身を値や参照で参照する場合がある。また参照先の正規表現が生存するために参照カウントを使っている。これにより循環参照が生じ、メモリリークが起きる可能性がある。xpressive は :cpp:class:`!tracking_ptr\<>` という型を使ってリークを回避している。本ドキュメントでは :cpp:class:`!tracking_ptr\<>` の、高水準な観点からの振る舞いについて述べる。


制限
~~~~

以下に挙げる設計上の制限を満たす解法でなければならない。

* 懸垂参照が発生しない：直接・間接的に参照しているオブジェクトはすべて参照が必要な限りは生存しなければならない。
* メモリリークが発生しない：オブジェクトは、最終的にはすべて確実に解放しなければならない。
* ユーザーの介入がない：ユーザーによる明示的な循環回収ルーチン呼び出しを必要としてはならない。
* クリーンアップ処理が例外を送出しない：回収処理はデストラクタから呼び出される可能性が高いため、どのような事情があろうとも例外を送出してはならない。


ハンドル・ボディイディオム
~~~~~~~~~~~~~~~~~~~~~~~~~~

:cpp:class:`!tracking_ptr\<>` を使うには、型をハンドルとボディに分離しなければならない。xpressive の場合、ハンドル型は :cpp:class:`!basic_regex\<>` でありボディは :cpp:class:`!regex_impl\<>` である。ハンドルがボディへの :cpp:class:`!tracking_ptr\<>` をもつ。

ボディ型は :cpp:class:`!enable_reference_tracking\<>` を継承しなければならない。これで :cpp:class:`!tracking_ptr\<>` が使用する帳簿（bookkeeping）となるデータ構造がボディに与えられる。

#. :code:`std::set<shared_ptr<body> > refs_`：このボディが参照するボディのコレクション。
#. :code:`std::set<weak_ptr<body> > refs_`：このボディを参照するボディのコレクション。


参照と依存
~~~~~~~~~~

上記 1. を「参照」、2. を「依存」と呼ぶことにする。:cpp:class:`!tracking_ptr\<>` は直接参照されるオブジェクトと（他の参照を介して）間接的に参照されるオブジェクトの両方を参照の集合として扱う、ということは理解しておかなければならない。依存の集合についても同じことが当てはまる。言い換えると、各ボディはそのボディが必要とする他のあらゆるボディに対する直接の参照カウンタをもつ。

なぜこれが重要なのか？あるボディを参照するハンドルがなくなった時点で、そのすべての参照を懸垂参照を心配せずに即座に解放可能だからである。

参照と依存は相互交流の関係である。動作を以下に示す。

#. オブジェクトが他のオブジェクトを参照として得ると、参照先のオブジェクトは参照元のオブジェクトを依存として得る。
#. これに加えて参照元のオブジェクトは参照先のオブジェクトがもつ参照をすべて得、参照先のオブジェクトは参照元のオブジェクトがもつ依存をすべて得る。
#. オブジェクトが新たな参照を獲得すると、その参照はすべての依存オブジェクトにも追加される。
#. オブジェクトが新たな依存を獲得すると、その依存はすべての参照オブジェクトにも追加される。
#. オブジェクトが自分自身の依存をもつことは認められない。オブジェクトが自分自身を参照することは可能であり、よくある。

次のコードを考える。 ::

   sregex expr;
   {
       sregex group  = '(' >> by_ref(expr) >> ')';                 // (1)
       sregex fact   = +_d | group;                                // (2)
       sregex term   = fact >> *(('*' >> fact) | ('/' >> fact));   // (3)
       expr          = term >> *(('+' >> term) | ('-' >> term));   // (4)
   }                                                               // (5)

参照と依存がどのように伝播するか 1 行ずつ見ていく。

.. list-table::
   :header-rows: 1

   * - 式
     - 効果
   * - 1）\ :code:`sregex group = '(' >> by_ref(expr) >> ')';`
     - ::

          group: cnt1 refs{expr} deps={}
          expr: cnt2 refs{} deps={group}
   * - 2）\ :code:`sregex fact = +_d | group;`
     - ::

         group: cnt2 refs{expr} deps={fact}
         expr: cnt3 refs{} deps={group,fact}
         fact: cnt1 refs{expr,group} deps={}
   * - 3）\ :code:`sregex term = fact >> \*(('*' >> fact) | ('/' >> fact));`
     - ::

         group: cnt3 refs{expr} deps={fact,term}
         expr: cnt4 refs{} deps={group,fact,term}
         fact: cnt2 refs{expr,group} deps={term}
         term: cnt1 refs{expr,group,fact} deps={}
   * - 4）\ :code:`expr = term >> *(('+' >> term) | ('-' >> term));`
     - ::

         group: cnt5 refs{expr,group,fact,term} deps={expr,fact,term}
         expr: cnt5 refs{expr,group,fact,term} deps={group,fact,term}
         fact: cnt5 refs{expr,group,fact,term} deps={expr,group,term}
         term: cnt5 refs{expr,group,fact,term} deps={expr,group,fact}
   * - 5）\ :code:`}`
     - ::

         expr: cnt2 refs{expr,group,fact,term} deps={group,fact,term}
    
オブジェクトの循環が発生したときに参照と依存がどのように伝播するかを示している。（4）の行で循環が閉じられ、以降、各オブジェクトは他のオブジェクトに対して参照カウントをもつ。これでなぜリークしないのか？ 先を続けよう。


循環を破る（循環ブレーカ）
~~~~~~~~~~~~~~~~~~~~~~~~~~

ボディは参照と依存の集合をもつ、というところまでは分かった。循環をいつどこで破るかがまだ決まっていない。これはハンドルの一部になっている :cpp:class:`!tracking_ptr\<>` の仕事である。:cpp:class:`!tracking_ptr\<>` は 2 つの :cpp:class:`!shared_ptr` をもつ。1 つ目は明らかなように :cpp:class:`!shared_ptr\<body>` であり、このハンドルが参照するボディへの参照である。2 つ目の :cpp:class:`!shared_ptr` は循環を破るのに使用し、ボディへのハンドルがすべてスコープから出たときに、ボディがもつ参照の集合を解放する。

このことから分かるように 1 つのボディに対するハンドルは 2 つ以上になる可能性がある。実際、:cpp:class:`!tracking_ptr\<>` は「書き込み時コピー」セマンティクスを用いており、ハンドルをコピーするとボディは共有される。あるボディへのハンドルは、そのうちすべてスコープの外に出る。このとき、他のボディ（当該ボディそのものかもしれない）が参照を保持していてボディへの参照カウントは0より大きいかもしれない。しかし循環ブレーカはハンドル内にしか存在しないので、循環ブレーカの参照カウントは間違いなく 0 である。ハンドルが存在しなければ循環ブレーカも存在しない。

循環ブレーカが行うことは何だろう？ ボディが :cpp:class:`!std::set\<shared_ptr\<body> >` 型の参照の集合をもつことを思い出していただきたい。この型を「:cpp:type:`!references_type`」と呼ぶことにする。循環ブレーカは :cpp:class:`!shared_ptr\<references_type>` であり、以下に示すカスタムの削除オブジェクトを使う。 ::

   template<typename DerivedT>
   struct reference_deleter
   {
       void operator ()(std::set<shared_ptr<DerivedT> > *refs) const
       {
           refs->clear();
       }
   };

循環ブレーカの役割は、ボディへの最後のハンドルがなくなったときにボディがもつ参照の集合を解放すること、それだけである。

すべてのボディが最終的に解放されることが保証されるのは明らかである。ハンドルがすべてスコープから出ると、ボディがもつすべての参照が解放され、後には何も（非 0 の参照カウントも）残らない。リークが起こらないことが保証される。

以上のことから懸垂参照が発生しないことが保証される、と言うのは少し難しい。A 、B 、C の 3 つのボディがあるとしよう。A は B を参照し、B は C を参照する。B へのハンドルがすべてスコープから出ると、B がもつ参照の集合が解放される。A が（間接的に）使用しているにも関わらず、これでは C が削除されてしまうのではないか？ そうはならない。A は B だけでなく C も直接参照し続けるように、上記のように参照と依存を伝播しているため、このような状況は起こらない。B がもつ参照の集合が解放されても、各ボディは A が使用中のため削除されない。


将来
~~~~

:cpp:class:`!std::set` 、:cpp:class:`!shared_ptr` 、:cpp:class:`!weak_ptr` を使っているが、軒並み効率が悪い。手ごろなので使っているだけなのだが。改善できると思う。

また、オブジェクトが必要以上に長い時間生存する場合がある。 ::

   sregex b;
   {
       sregex a = _;
       b = by_ref(a);
       b = _;
   }
   // a がこの時点でまだ生存している！

参照と依存を伝播する手法であるため、:cpp:class:`!std::set` は拡大するのみである。参照が不要になった場合でも縮小しない。xpressive ではこれは問題にならない。参照オブジェクトのグラフは大きくならず、それぞれ孤立したままである。汎用の参照カウント式循環コレクション機構として :cpp:class:`!tracking_ptr\<>` を使おうとすると、この問題に焦点が当てられることになるだろう。
