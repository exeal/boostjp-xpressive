静的正規表現
^^^^^^^^^^^^

概要
~~~~

xpressive が他の C/C++ 正規表現ライブラリと一線を画すのは、C++ の式を用いて正規表現を記述する機能による。xpressive は演算子の多重定義と\ **式テンプレート**\という技術を使って、パターンマッチのための小言語を C++ に組み込むことでこれを実現している。これら「静的正規表現」には文字列ベースのものに比較して多くの利点がある。特に以下の点を挙げておく。

* コンパイル時に構文がチェックされる。実行時に構文エラーで失敗することがない。
* 他の C++ データ、コード、他の正規表現を自然に参照できる。正規表現の外部での文法構築、および正規表現マッチの一部として実行されるユーザー定義アクションの束縛が簡単になる。
* 静的束縛され、インライン化と最適化が促進される。静的正規表現は状態表、仮想関数、バイトコード、関数ポインタによる呼び出しといったコンパイル時に解決できないものを必要としない。
* 検索対象が文字列に限定されない。例えば、数値配列からパターンを探索する静的正規表現を宣言できる。
* 静的正規表現の組み立ては C++ の式を使うので、合法な C++ の式規則の制約を受ける。残念ながら、「伝統的な」正規表現構文をすべてきれいに C++ に対応させられるわけではない。そういうわけで、無理な対応は試みず C++ として合法な構文を用意する。

構築と代入
~~~~~~~~~~

静的正規表現の作成は、:cpp:struct:`basic_regex\<>` 型のオブジェクトへの代入により行う。例えば、以下は :cpp:type:`!std::string` 型のオブジェクトに対してパターンを探索する正規表現を定義する。 ::

   sregex re = '$' >> +_d >> '.' >> _d >> _d;

代入の動作も似たようなものである。


文字と文字列リテラル
~~~~~~~~~~~~~~~~~~~~

静的正規表現において、文字と文字列リテラルはそれ自身にマッチする。例えば上の正規表現において :cpp:expr:`'$'` と :cpp:expr:`'.'` は、それぞれ文字 :regexp:`'$'` 、:regexp:`'.'` にマッチする。Perlにおいて :regexp:`$` と :regexp:`.` がメタ文字であるからといって混乱しないでいただきたい。xpressive ではリテラルは常にそれ自身を表す。

静的正規表現でリテラルを使用する場合は、少なくとも片方のオペランドはリテラル以外であることに注意しなければならない。例えば以下は正しい正規表現では\ **ない**\。 ::

   sregex re1 = 'a' >> 'b';         // エラー！
   sregex re2 = +'a';               // エラー！

二項 :code:`>>` 演算子の2つのオペランドが両方ともリテラル、また単項 :code:`+` 演算子のオペランドもリテラルになっている。よってこれらの文は組み込みの C++ 二項右シフト、単項プラス演算子をそれぞれ呼び出す。これは期待した動作ではない。演算子の多重定義が機能するには、少なくとも 1 つのオペランドがユーザー定義型でなければならない。xpressive の :cpp:func:`as_xpr()` ヘルパ関数を使うと式を正規表現の世界に「引き込み」、演算子の多重定義に正しい演算子を見つけるよう強制できる。上の 2 つは次のように書くべきだ。 ::

   sregex re1 = as_xpr('a') >> 'b'; // OK
   sregex re2 = +as_xpr('a');       // OK


結合と選択
~~~~~~~~~~

すでに見てきたように、静的正規表現における部分式は結合演算子 :code:`>>` で分離されていなければならない。この演算子は「～の後に」などと読み替えるとよい。 [#]_ ::

   // 後ろに数字が続く 'a' にマッチ
   sregex re = 'a' >> _d;

選択（分岐）は :code:`|` 演算子を使用する。Perl と同様の動作をする。この演算子は「または」などと読み替えるとよい。例えば、 ::

   // 1 文字以上の数字、または単語構成文字にマッチ
   sregex re = +( _d | _w );


グループ化と捕捉
~~~~~~~~~~~~~~~~

Perl では括弧 :code:`()` は特別な意味をもつ。これらはグループ化を行うが、:code:`$1` や :code:`$2` といった後方参照を作成するという副作用がある。C++ では括弧を多重定義して副作用を与えることはできない。そこで同じ効果を得るために :cpp:var:`s1` や :cpp:var:`s2` という特殊なトークンを使用する。これらに代入を行うことで後方参照を作成する。後方参照は Perl の :code:`\\1` や :code:`\\2` のような使い方で式中で使用できる。例えば以下の HTML タグのマッチを探索する正規表現を考えよう。 ::

   "<(\\w+)>.*?</\\1>"

静的正規表現では、次のようになる。 ::

   '<' >> (s1= +_w) >> '>' >> -*_ >> "</" >> s1 >> '>'

:cpp:var:`s1` への代入により後方参照を捕捉し、パターンの後ろのほうでマッチする終了タグを探索するのに :cpp:var:`s1` を使っていることに注意していただきたい。

.. tip:: 後方参照を捕捉せずにグループ化けを行う

   * xpressive では、後方参照を捕捉せずにグループ化を行うには :cpp:var:`s1` なしで :code:`()` を使うだけでよい。これは Perl の捕捉なしのグループ化構造 :regexp:`(?:)` と等価である。


.. [#] 訳注　原文は “followed by”。無理に日本語にしないほうがいいかもしれません…。
